from typing import Any, TYPE_CHECKING, Optional

from fastapi import Depends

from app.api.v1.utils import PasswordHelper
from app.api.v1.managers.db import get_user_db_manager

from app.core.types import DependencyCallable
from app.core.exceptions import (
    InvalidID,
    UserNotExists,
    UserAlreadyExists,
)

if TYPE_CHECKING:
    from fastapi.security import OAuth2PasswordRequestForm

    from app.api.v1.managers.db import UserDatabaseManager

    from app.core.models import User
    from app.core.schemas import UserCreateSchema, UserUpdateSchema


class UserManager:
    """
    User management logic.

    :param user_db: User database manager instance.
    """

    reset_password_token_lifetime_seconds: int = 60 * 30
    verification_code_lifetime_seconds: int = 60 * 30

    def __init__(self, user_db: "UserDatabaseManager"):
        self.user_db = user_db
        self.password_helper = PasswordHelper()

    # noinspection PyMethodMayBeStatic
    def parse_id(self, value: Any) -> int:
        """
        Convert the value to a valid integer instance.

        :param value: The value to parse.
        :raises InvalidID: The id value is invalid.
        :return: An integer object.
        """
        if isinstance(value, float):
            raise InvalidID()
        try:
            return int(value)
        except ValueError as e:
            raise InvalidID() from e

    async def get(self, user_id: int) -> "User":
        """
        Get a user by id.

        :param user_id: Identifier of the user to retrieve.
        :raises UserNotExists: The user does not exist.
        :return: A user.
        """
        user = await self.user_db.get(user_id)

        if user is None:
            raise UserNotExists()

        return user

    async def get_by_email(self, email: str) -> "User":
        """
        Get a user by e-mail.

        :param email: E-mail of the user to retrieve.
        :raises UserNotExists: The user does not exist.
        :return: A user.
        """
        user = await self.user_db.get_by_email(email)

        if user is None:
            raise UserNotExists()

        return user

    async def create(
        self, user_create: "UserCreateSchema", safe: bool = False
    ) -> "User":
        """
        Create a user in database.

        Triggers the on_after_register handler on success.

        :param user_create: The UserCreate model to create.
        :param safe: If True, sensitive values like is_superuser or is_verified
        will be ignored during the creation, defaults to False.
        :raises UserAlreadyExists: A user already exists with the same e-mail.
        :return: A new user.
        """
        self.password_helper.validate_password(user_create.password)

        existing_user = await self.user_db.get_by_email(user_create.email)

        if existing_user is not None:
            raise UserAlreadyExists()

        user_dict = (
            user_create.create_update_dict()
            if safe
            else user_create.create_update_dict_superuser()
        )
        password = user_dict.pop("password")
        user_dict["hashed_password"] = self.password_helper.hash(password)

        created_user = await self.user_db.create(user_dict)

        await self.on_after_register(created_user)

        return created_user

    async def request_verify(self, user: "User") -> None:
        """
        Start a verification request.

        Triggers the on_after_request_verify handler on success.

        :param user: The user to verify.
        :raises UserInactive: The user is inactive.
        :raises UserAlreadyVerified: The user is already verified.
        """
        pass

    async def verify(self, code: str) -> "User":
        """
        Validate a verification request.

        Changes the is_verified flag of the user to True.

        Triggers the on_after_verify handler on success.

        :param code: The verification code generated by request_verify.
        :raises InvalidVerifyToken: The token is invalid or expired.
        :raises UserAlreadyVerified: The user is already verified.
        :return: The verified user.
        """
        pass

    async def forgot_password(self, user: "User") -> None:
        """
        Start a forgot password request.

        Triggers the on_after_forgot_password handler on success.

        :param user: The user that forgot its password.
        :raises UserInactive: The user is inactive.
        """
        pass

    async def reset_password(self, token: str, password: str) -> "User":
        """
        Reset the password of a user.

        Triggers the on_after_reset_password handler on success.

        :param token: The token generated by forgot_password.
        :param password: The new password to set.
        :raises InvalidResetPasswordToken: The token is invalid or expired.
        :raises UserInactive: The user is inactive.
        :raises InvalidPasswordException: The password is invalid.
        :return: The user with updated password.
        """
        pass

    async def update(
        self,
        user_update: "UserUpdateSchema",
        user: "User",
        safe: bool = False,
    ) -> "User":
        """
        Update a user.

        Triggers the on_after_update handler on success

        :param user_update: The UserUpdate model containing
        the changes to apply to the user.
        :param user: The current user to update.
        :param safe: If True, sensitive values like is_superuser or is_verified
        will be ignored during the update, defaults to False
        :return: The updated user.
        """
        user_dict = (
            user_update.create_update_dict()
            if safe
            else user_update.create_update_dict_superuser()
        )

        updated_user = await self._update(user, user_dict)

        await self.on_after_update(updated_user)

        return updated_user

    async def delete(self, user: "User") -> None:
        """
        Delete a user.

        :param user: The user to delete.
        """
        await self.user_db.delete(user)

    async def on_after_register(self, user: "User") -> None:
        """
        Perform logic after successful user registration.

        :param user: The registered user
        """
        return

    async def on_after_update(self, user: "User") -> None:
        """
        Perform logic after successful user update.

        :param user: The updated user
        """
        return

    async def on_after_request_verify(self, user: "User", token: str) -> None:
        """
        Perform logic after successful verification request.

        :param user: The user to verify.
        :param token: The verification token.
        """
        return

    async def on_after_verify(self, user: "User") -> None:
        """
        Perform logic after successful user verification.

        :param user: The verified user.
        """
        return

    async def on_after_forgot_password(self, user: "User") -> None:
        """
        Perform logic after successful forgot password request.

        :param user: The user that forgot its password.
        """
        return

    async def on_after_reset_password(self, user: "User") -> None:
        """
        Perform logic after successful password reset.

        :param user: The user that reset its password.
        """
        return

    async def authenticate(
        self, credentials: "OAuth2PasswordRequestForm"
    ) -> Optional["User"]:
        """
        Authenticate and return a user following an email and a password.

        :param credentials: The user credentials.
        :return: The user if successful.
        """
        try:
            user = await self.get_by_email(credentials.username)
        except UserNotExists:
            self.password_helper.hash(credentials.password)
            return None

        verified, updated_password_hash = self.password_helper.verify_and_update(
            credentials.password, user.hashed_password
        )

        if not verified:
            return None

        if updated_password_hash is not None:
            await self.user_db.update(user, {"hashed_password": updated_password_hash})

        return user

    async def _update(self, user: "User", update_dict: dict[str, Any]) -> "User":
        validated_update_dict = {}

        for field, value in update_dict.items():
            if field == "email" and value != user.email:
                try:
                    await self.get_by_email(value)
                    raise UserAlreadyExists()
                except UserNotExists:
                    validated_update_dict["email"] = value
                    validated_update_dict["is_verified"] = False
            elif field == "password" and value is not None:
                self.password_helper.validate_password(value)
                validated_update_dict["hashed_password"] = self.password_helper.hash(
                    value
                )
            else:
                validated_update_dict[field] = value

        return await self.user_db.update(user, validated_update_dict)


UserManagerDependency = DependencyCallable[UserManager]


async def get_user_manager(user_db=Depends(get_user_db_manager)):
    yield UserManager(user_db)
